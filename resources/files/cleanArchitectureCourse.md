# Clean Architecture

A 2-3 day course for senior programmers that describes the fundamentals of software architecture.

**Audience:** 
* Senior programmers, Technical Leads, and Architects who desire to improve their knowledge 
and skills with regard to high level software structure and architeture.

**Duration:** 
* The two day version is weighted towards lecture and demonstration with a minimum of exercises.
* The three day version shifts the weight towards in-class practice and exercises, without
diminishing the lectures and demonstrations.

**Outcomes** <br>
After this class students will:
* ...understand the goals and aims of software architecture.
* ...understand the three fundamental paradigms of software development.
* ...understand the principles of mid-to-high-level software design.
* ...be able to separate systems into independently deployable high-level components.
* ...understand the role and proper placement of architectural boundaries.
* ...be able to create boundaries based on the concept of policy-level.
* ...be able to determine whether boundaries should be full or partial.
* ...understand the architectural role of GUIs, databases, and frameworks.
* ...understand the role and composition of the Main component.
* ...understand the architectural role of services and micro-services.


## Outline ##
* **What is Design and Architecture?** <br>
Presents the definitions and motivations of software architecture and high level design.
<p>
* **A Tale of Two Values.**<br>
The two values of software: Behavior and Structure
 * Behavior
 * Structure
 * Architecture
 * Scope vs. Shape
 * The Value of Change
<p>
* **Programming Paradigms**<br>
 * Structured Programming
  * Math vs. Science.
 * Object-Oriented Programming
  * Dependency Inversion
 * Functional Programming
  * Event Sourcing
 * ...and Architecture
<p>
* **Design Principles**<br>
A high level presentation of mid-to-high-level design.
 * Mid-level SOLID principles
  * (SRP) The Single Responsibility Principle
  * (OCP) The Open-Closed Principle
  * (LSP) The Liskov Substitution Principle
  * (ISP) The Interface Segregation Principle
  * (DIP) The Dependency Inversion Principle
 * High-level component principles
  * What are components.  History and Definition.
  * Component Cohesion
   * (REP) The Release-Reuse Equivalence Principle
   * (CCP) The Common Clojure Principle
   * (CRP) The Common Reuse Principle
  * Component Coupling
   * (ADP) The Acyclic Dependencies Principle
   * (SDP) The Stable Dependencies Principle
   * (SAP) The Stable Abstractions Principle
<p>
* **Architecture**<br>
A deep dive into the anatomy and physiology of software architecture.
 * Keeping Options Open.
 * Independence
  * Deployment
  * Development
  * Decoupling Modes
 * Boundaries
  * The Art of Drawing Lines
  * Plugins
  * Boundary Crossing
  * Deployment Boundaries
 * Policy and Level
  * Business Rules
  * Entities
  * Use Cases
 * Screaming Architecture
 * The Clean Architecture
  * The Dependency Rule
  * Presenters and Humble Objects
  * Databases and Gateways
  * Service Listeners
 * Partial Boundaries
 * Layers and Boundaries
 * The Main Component
 * Services Great and Small
 * The Test Boundary
<p>
* **Details**
 * Databases
 * The Web
 * Frameworks
<p>
* **Exercises.** <br>
Several design exercises and demonstrations using UML as time permits.
 
  

 
 


