# The _SOLID_ Principles of Software Design
A 2-3 day course for programmers of any experience level that describes the _SOLID_ principles of
Object-Oriented software design, and the associated principles of _component_ design.

**Audience:** 
* Programmers of all levels of experience who desire to improve their software design skills._

**Duration:** 
* The two day version is weighted towards lecture and demonstration with a minimum of exercises.
* The three day version shifts the weight towards in-class practice and exercises, without
diminishing the lectures and demonstrations.

**Outcomes** <br>
After this class students will:
* ...understand that modules should have only one reason to change; and be able
to structure systems to minimize the effects of change.
* ...understand that a good software design allows new features to be added without
changing existing code.
* ...be able to construct inheritance and polymorphic hierarchies that adhere to a consistent
interface with their users.
* ...understand how to separate interfaces and operations so that low level changes to not
propagate to higher levels.
* ...have a firm grasp on how to manage the dependencies between source code modules such
that high level policy does not depend upon low level detail.
* ...be able to allocate modules into reusable components.
* ...understand how to separate functionality between components in order to minimize change.
* ...be able to manage the dependencies between components to minimize crosstalk and deployment thrashing.
* ...be able to organize component structures into developable and releasable structures.
* ...understand how to connect components such that changes propagate in the right direction.
* ...know how to allocate classes to components such that high level components do not 
depend on low level components.
* ...be familiar with a set of design quality metrics that can be applied to measure the quality
of module and component structures.

## Outline ##
* **What goes wrong with Software?**
 * Design Smells
  * Rigidity
  * Fragility
  * Inseparability
  * Viscosity
 * Code Smells
  * 
<p>
* **What is OO?**
 * History of OO
 * Dependency Management
 * Dependency Inversion
 * Plug-in Architecture
<p>
* **Code Rot**
 * Example: The Copy Program
<p>
* **The SOLID Principles**<br>
An in-depth presentation of the principles of class and module design.
 * **(SRP)** The Single Reponsibility Principle
 * **(OCP)** The Open-Closed Principle
 * **(LSP)** The Liskov Substitution Principle
 * **(ISP)** The Interface Segregation Principle
 * **(DIP)** The Dependency Inversion Principle
<p>
* **Component Principles**
An in-depth presentation of the principles of component cohesion and coupling.
 * What is a component?
 * Cohesion Principles
  * **(REP)** The Release Reuse Equivalence Principle
  * **(CCP)** The Common Closure Principle
  * **(CRP)** The Common Reuse Principle
 * Coupling Principles
  * **(ADP)** The Acyclic Dependencies Principle
  * **(SDP)** The Stable Dependencies Principle
  * **(SAP)** The Stable Abstractions Principle
 * Design Quality Metrics
<p>
* **Exercises.** <br>
Several design exercises and demonstrations using UML as time permits.

 


